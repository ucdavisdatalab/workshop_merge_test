File Paths
==========

Due to the nature of its stripped down display, the command line interface can 
at times feel a bit static. But it offers much of the same functionality that 
modern GUIs offer, including the ability to move around your computer. With GUIs, 
we tend to navigate with our mouses; on the command line, we'll use our keyboard. 
The live workshop session will cover this in depth, but for now it's important to 
have a working sense of how your files are structured.

Your computer uses a **directory structure** to organize all of your files. This 
structure is like a map of all the places you can navigate to. Each file has an 
**address** on this map, and there is a **path** that leads to it. When you use a 
GUI, your computer does the work of determining which path to follow to find 
the file or folder you'd like to open, but performing the same operation with the 
command line interface requires us to manually specify where we'd like to go.

We do this with the following syntax:

```
/this/is/a/path/to/your/file.txt
```

This is called a **file path**.

Path Hierarchies
----------------

Importantly, the structure of your computer's directory is **hierarchical**. 
Directories nest inside one another, and you need to have a sense of which 
directories are "above" or "below" the present file path to navigate with the
command line interface.

The top-most directory in your computer is called `root`. Unix systems denote it 
with the `/` character. It's like the trunk of a tree: every directory in your 
computer branches off from it.

A complication arises from the fact that directories can also  branch off from 
each other. Whenever you make a folder within another folder---or a 
**subdirectory**---you've created another branch in the tree, one which is at the same time a branch of `root` *and* a branch of whatever directory you're 
currently in. For example, this is the structure of the practice exercise we'll 
be using during our live session:

```
.                               top of the directory
├── instructions.md             file in the top of the directory
├── instructions.pdf            ""
└── level_1                     first subdirectory
    ├── level_2a                a second subdirectory, below level_1
    │   ├── 2.txt               file in the second subdirectory
    │   └── extra_file.txt      ""
    ├── level_2b                another subdirectory, at the same level as level_2a
    │   └── level_3             third subdirectory, below level_2a and level_2b
    │       └── 1.txt           file in the third subdirectory
    └── wrong_name.txt          file in first subdirectory
```

As you can see, this can get complicated! When you're first getting started with 
the command line, it's easy to feel a little lost and forget where you are in 
your computer. We'll discuss some strategies to help with this in the live 
session, but know for the moment that the `pwd` command will always tell you where 
you are relative to `root`:

```
$ pwd
/here/is/where/you/are/located/in/your/computer
```

Absolute vs. Relative Paths
---------------------------

The path above begins with `/`, which, remember, is `root`. When you see a path 
that begins with `/`, it's showing you the full, or **absolute** location of a 
directory or file. No matter where you are in your computer, no matter how deep 
into a series of subdirectories you may be, if you used this absolute path with 
a navigation command, you could go straight to the location it indicates.

By contrast, a **relative path** is context-specific. It depends on wherever you 
are in your computer. Unix uses some shorthand for this: `.` denotes the current 
location in your computer, while `..` denotes the directory above that location. 
We can use this shorthand to avoid having to type out the entire path to a file 
or directory (this is useful if you're far away from `root`). To continue with 
the example from above, if you're at `computer`:

```
/here/is/where/you/are/located/in/your/computer
                                       ^^^^^^^^
```

And you want to get to `located`:

```
/here/is/where/you/are/located/in/your/computer
                       ^^^^^^^
```

You could use an absolute path to get there, which would be:

```
/here/is/where/you/are/located
```

Or, you could use a relative path:

```
../../../
```

This would take you three directories up from `computer`, which, as you can see 
above, is `located` (count the names between backslashes). That's much shorter, 
but there's a downside: those `..` sequences are pretty hard to read without 
context, and it's easy to get confused. Clearly, there can sometimes be a 
trade-off between using absolute and relative paths.